
from typing import Tuple
import base64
import codecs
import math
from random import SystemRandom
from utils.http import HTTPException, Status

# Extremely large prime used to ensure proper randomness and stop users getting info from individual shares
_PRIME = 115792089237316195423570985008687907853269984665640564039457584007913129639747

def _greatest_common_divisor(a: int, b: int):
    """ Calculates the largest integer that is divides both a and b """            
    if b == 0:
        return [1, 0]
    else:
        div_number = int(math.floor(a*1.0/b))
        mod = a % b
        r = _greatest_common_divisor(b, mod)
        return [r[1], r[0] - r[1]*div_number]

def _mod_inverse(number):
    """ 
    Calculates the modular inverse of _PRIME and the number.
    
    Modular inverse is such that if A mod B then A * B mod C = 1. Where C is the modular inverse
    """
    
    remainder = _greatest_common_divisor(_PRIME, number % _PRIME)[1]
    if number < 0:
        remainder *= -1
    return remainder
       
class _SecretSplitter:
    """ Gives splitting and merging utilities for secrets. """
    
    @classmethod
    def split(self, secret: str) -> list[int]:
        """ Splits a latin-1 encoded secret into a list of 32byte ints"""
        split_ints: list[int] = []

        encoded_secret = bytes(secret, "latin-1")
        secret_as_hex = codecs.encode(encoded_secret, 'hex_codec').decode('latin-1')
        
        # pad so it is a multiple of 64 hex long
        padding = "00"*(32 - (len(encoded_secret) % 32))
        secret_as_hex = secret_as_hex + padding
        
        int_hex_size = 64
        int_amount = int(len(secret_as_hex)/int_hex_size)

        # split every 64 hex / 32 bytes and convert to int
        for i in range(0, int_amount):
            split_ints.append(int(secret_as_hex[i*int_hex_size : (i+1)*int_hex_size], 16))

        return split_ints

    @classmethod
    def merge(self, ints: list[int]) -> str:
        """ Merges a list of 32byte ints into a latin-1 encoded secret. """
        
        hex_encoded_secret = ""

        for value in ints:
            hex_encoded_int = hex(value)[2:].replace("L", "")
            padding = "0"*(64 - (len(hex_encoded_int)))
            hex_encoded_secret += padding + hex_encoded_int

        hex_encoded_bytes = bytes(hex_encoded_secret, "latin-1")

        return codecs.decode(hex_encoded_bytes, 'hex_codec').decode('latin-1').rstrip("\00\x00")
    

class _Base64:
    @classmethod
    def encode(self, number: int) -> str:
        """
        Converts 32 byte long number to base64.
    
        Encoded hex ends up length 44 because each 4 bits, of the 32 byte 
        long number, become 6 after encoding.
        """
        number_as_hex = hex(number)[2:].replace("L", "")
        padded_hex = "0"*(64 - len(number_as_hex)) + number_as_hex

        byte_encoded = bytes(padded_hex, "latin-1")

        encoded_number = str(base64.urlsafe_b64encode(b'\00'*(64 - len(byte_encoded)) + codecs.decode(byte_encoded, 'hex_codec')).decode('latin-1'))

        if len(encoded_number) != 44:
            raise HTTPException(Status.InternalServerError, "failed to encode number into base64")
        
        return encoded_number
        
    @classmethod
    def decode(self, encoded: str) -> int:
        """ Converts a base64 string into an int. """
        encoded_bytes = bytes(encoded, "latin-1")
        base64_decoded_bytes = base64.urlsafe_b64decode(encoded_bytes)
        hex_encoded_bytes = codecs.encode(base64_decoded_bytes, 'hex_codec')
        return int(hex_encoded_bytes, 16)

class _UniqueRandomGenerator:  
    def __init__(self):
        self.used_random_numbers = [0]
        
    @classmethod
    def _random(self):
        """ Generates a system random number between 0 and a extremely large prime """
        return SystemRandom().randrange(0, _PRIME)
        
    def next(self) -> int:
        """ Returns a random number between 1 and prime that hasn't been generated by this instance before. """
        random_number = self._random()
            
        # ensure new random number hasn't been used
        while random_number in self.used_random_numbers:
            random_number = self._random()
            
        self.used_random_numbers.append(random_number)
        
        return random_number
    
class _Polynomial:
    def __init__(self):
        self.coefficients: list[int] = []
        
    def coefficient(self, coeff: int):
        self.coefficients.append(coeff)
        
    def evaluate(self, x: int) -> int:
        result = 0
        for coefficient in reversed(self.coefficients):
            result = result * x + coefficient
            result = result % _PRIME

        return result
        
class _Share:
    def __init__(self, encoded_share: str = None):
        if encoded_share == None:
            self.x = []
            self.y = []
            return
        
        share_len = 88
        if len(encoded_share) % share_len != 0:
            raise HTTPException(Status.BadRequest, "share is wrong length")
        
        count = int(len(encoded_share) / share_len)
        self.x = []
        self.y = []
        for i in range(0, count):
            cshare = encoded_share[i*share_len : (i+1)*share_len]
            self.x.append(_Base64.decode(cshare[0:44]))
            self.y.append(_Base64.decode(cshare[44:88]))
            
    def __iter__(self):
        if len(self.x) != len(self.y):
            raise HTTPException(Status.InternalServerError, "amount of share's x values does not equal y")
        
        for i in range(len(self.x)):
            yield (self.x[i], self.y[i])
            
    def secret_len(self):
        return len(self.x)
    
    def __getitem__(self, i: int) -> Tuple[int, int]:
        return self.x[i], self.y[i]
            
    def next_pair(self, x: int, y: int):
        self.x.append(x)
        self.y.append(y)
            
    def encode(self) -> str:
        if len(self.x) != len(self.y):
            raise HTTPException(Status.InternalServerError, "amount of share's x values does not equal y")
        
        encoded_share = ""
        for i in range(len(self.x)):
            encoded_share += _Base64.encode(self.x[i])
            encoded_share += _Base64.encode(self.y[i])
        return encoded_share
        

class ShamirSecretSharing:
    """
        Allows a secret to be split into multiple parts (called shares) that given a minimum number of these
        shares we can re-assemble the original secret. If less than the minimum is provided then the secret
        cannot be re-constructed.
        
        #### Basic Concept of Algorithms
        ##### Share Creation
        First you create a polynomial that has an amount coefficients equal to the minimum and setting
        the first coefficient (the one that normally wouldn't be multiplied by anything) to the secret
        and the rest to random non-zero numbers that are between 1 and a massive prime.
            e.g. (minimum = 2, secret = 1234) => 1234 + 23x + 128x^2
                 where 23 and 128 are the generated random numbers
        
        Then using this polynomial we can create shares by inputting a share count amount of random numbers 
        (1 to large prime) into it to produce a set of (x, y) pairs.
            e.g. (polynomial = 1234 + 23x + 128x^2, share_count = 5, random_numbers = [25, 16, 69, 123, 324]) 
                shares:
                    polynomial(25) = 80,000 => (x = 25, y = 80,000)  
                    
                    polynomial(16) = 5,888 => (x = 16, y = 5,888)  
                    
                    polynomial(69) = 612,229 => (x = 69, y = 612,229)  
                    
                    polynomial(123) = 1,940,575 => (x = 123, y = 1,940,575)  
                    
                    polynomial(324) = 13,445,614 => (x = 324, y = 13,445,614)  
        
        Then knowing a minimum number of input => output pairs for that given polynomial we can
        find out the original problem.
        """
    
    @classmethod
    def create(self, minimum: int, share_count: int, secret: str) -> list[str]:
        if (share_count < minimum):
            raise HTTPException(Status.BadRequest, "share count is less than minimum required shares")

        # split secret as it must be in consistent 16 bit ints
        split_secret = _SecretSplitter.split(secret)
        
        random_gen = _UniqueRandomGenerator()
        
        polynomial_per_split: list[_Polynomial] = []
        for i in range(0, len(split_secret)):
            new_polynomial = _Polynomial()
            new_polynomial.coefficient(split_secret[i])
            polynomial_per_split.append(new_polynomial)
            # generate an extra minimum-1 coefficients for this split
            for j in range(1, minimum):
                coeff = random_gen.next()
                polynomial_per_split[i].coefficient(coeff)

        shares = []

        for i in range(0, share_count):
            # create a single share from the split secret
            new_share = _Share()
            for j in range(0, len(split_secret)):
                share_x = random_gen.next()
                new_share.next_pair(share_x, polynomial_per_split[j].evaluate(share_x))
            shares.append(new_share.encode())

        return shares

    @classmethod
    def combine(self, shares: list[str]):
        decoded_shares: list[_Share] = []

        for share in shares:
            decoded_shares.append(_Share(share))

        split_secret = [0] * decoded_shares[0].secret_len()

        for secret_index in range(decoded_shares[0].secret_len()):
            for share_index, share in enumerate(decoded_shares):
                x, y = share[0]
                numerator = 1
                denominator = 1
                for other_share_index, other_share in enumerate(decoded_shares):
                    if share_index != other_share_index:
                        other_x = other_share[secret_index][0]
                        numerator = (numerator * (-1*other_x)) % _PRIME
                        denominator = (denominator * (x - other_x)) % _PRIME

                working = ((y * numerator * _mod_inverse(denominator)) + _PRIME)
                split_secret[secret_index] = (split_secret[secret_index] + working) % _PRIME

        return _SecretSplitter.merge(split_secret)